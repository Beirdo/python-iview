#!/usr/bin/env python3

import sys, os, argparse
import os.path
import iview.config
import configparser

def config():
	try:
		iview.comm.get_config()
	except HTTPError as error:
		print("""\
Error: could not retrieve an important configuration file from iView.
Please make sure you are connected to the Internet.

If iView works fine in your web browser, the iView API has possibly changed.
Try to find an updated version of this program or contact the author.

Debug: could not load URL {}""".format(error.url), file=sys.stderr)
		sys.exit(1)

def programme():
	"""	Downloads the iView index, and then prints each item in all series.
		This is a slow function. Using index() and subsequently cherrypicking
		a series to pass to series() is much faster.
	"""
	config()
	index = iview.comm.get_keyword('index')

	for series in index:
		print(series['title'] + ':')
		print_series_items(series['items'], indent='\t')

def index():
	"""	Downloads the iView index, and prints the corresponding series and IDs.
	"""
	config()
	index = iview.comm.get_index()

	for series in index:
		print(series['id'] + '\t' + series['title'])

def batch_index():
	"""	Downloads the iView index, and prints the corresponding series and IDs in a format
		that works in the iview batch file
	"""
	config()
	index = iview.comm.get_index()

	for series in index:
		print(series['id'] + ': ' + series['title'])

def series(series_id):
	config()
	print_series_items(iview.comm.get_series_items(series_id))

def print_series_items(items, indent=''):
	for item in items:
		if item['livestream']:
			url = item['livestream']
		else:
			url = item['url']
		print(indent + item['title'] + '\t(' + url + ')')

def print_auth():
	config()
	auth = iview.comm.get_auth()
	print('iView auth data:')
	print('\tToken:', auth['token'])
	print('\tRTMP URL:', auth['rtmp_url'])
	print('\tPlaypath Prefix:', auth['playpath_prefix'])
	print('\tUnmetered:', str(auth['free']))

def download(url, output=None):
	config()
	iview.fetch.fetch_program(url, execvp=True, dest_file=output)

def batch(batch_file):
	config()

	# parse the batch file
	batch = configparser.ConfigParser()
	batch.read(os.path.expanduser(batch_file))
	items = batch.items('batch')

	batch_destination = '.'
	series_ids = []
	last_only = False

	# separate options from the series ids
	for key, value in items:
		if key == 'destination':
			batch_destination = value
		elif key == 'last_only':
			if not(value == '0' or value.lower() == 'false' or value.lower() == "no"):
				last_only = True
		else:
			# Note: currently the value after the series_id in the batch file
			# is only used as a comment for the user.
			series_ids.append(key)

	# move to where the files should be downloaded
	os.chdir(batch_destination)

	# loop through the series ids
	for series_id in series_ids:

		# unset the last episode for the current series.
		last_episode = None

		# loop through the episodes
		episodes = iview.comm.get_series_items(series_id)
		for episode in episodes:
			if last_only:
				# This last_only feature is experimental, I am not sure which field to 
				# use to determine the most recent episode.
				if last_episode == None or episode['date'] > last_episode['date']:
					last_episode = episode
			else:
				batch_fetch_program(episode)

		# Last only means we only get one episode for the series
		if last_only:
			batch_fetch_program(last_episode)

def batch_fetch_program(episode):
	# Only print notification messages for episodes that have never been downloaded before.

	# urls sometimes include a path like 'news/' or 'kids/'
	(pathpart, filepart) = os.path.split(episode['url'])

	# urls also have '.mp4' extension but downloaded files end in '.flv'
	(base, ext) = os.path.splitext(filepart)

	if not os.path.isfile(base + '.flv'):
		msg = "getting " + episode['title'] + " - " + episode['url']
		print(msg, file=sys.stderr)
	iview.fetch.fetch_program(episode['url'], execvp=False, dest_file=None, quiet=True)


def subtitles(name, output=None):
	config()

	url = ''.join(name.split('.')[:-1])
	if output is not None:
		srt = output
	else:
		srt = ''.join(url.split('/')[-1]) + '.srt'

	if not srt == '-' and os.path.isfile(srt):
		print('Subtitles have already been downloaded to %s' % srt, file=sys.stderr)
		return False

	print('Downloading subtitles to %s...' % srt, end=' ', file=sys.stderr)

	try:
		subtitles = iview.comm.get_captions(url)
	except HTTPError as error:
		print('failed', file=sys.stderr)
		print('Got an error when downloading %s' % error.url, file=sys.stderr)
		return False
	except KeyboardInterrupt:
		return False

	if not srt == '-':
		f = open(srt, 'wb')
	else:
		f = sys.stdout

	f.write(subtitles.encode('utf-8'))
	f.flush()

	if not srt == '-':
		os.fsync(f.fileno())

	f.close()

	print('done', file=sys.stderr)

def parse_proxy_argument(proxy):
	"""	Try to parse 'proxy' as host:port pair.  Returns an error message
		if it cannot be understood.  Otherwise, it configures the settings
		in iview.config and returns None
	"""

	# this could be done much nicer with partition()
	# but it's not available in older versions of python
	parts = proxy.split(':')
	if len(parts) == 2:
		try:
			iview.config.socks_proxy_port = int(parts[1])
		except ValueError:
			return "Port '%s' is not numeric" % parts[1]
	elif len(parts) != 1:
		return "Too many ':' in '%s'" % proxy
	iview.config.socks_proxy_host = parts[0]

	return None

params = argparse.ArgumentParser()
params.add_argument("-i", "--index", action="store_true",
	help="prints the iView index (number is the series ID)")
params.add_argument("-s", "--series", metavar="<id>",
	help="get the list of episodes for the series")
params.add_argument("-p", "--programme", action="store_true", help=
	"prints the entire iView programme at once (warning: very slow!)")
params.add_argument("-d", "--download", metavar="<url>", 
	help="download an episode (pass the url you got from -s or -p)")
params.add_argument("-t", "--subtitles" , metavar="<url>",
	help="""download subtitles in SRT format for an episode (pass the
	same url as for --download)""")
params.add_argument("-o", "--output", metavar="<file>",
	help="specify a file to output to (use - for stdout)")
params.add_argument("--batch", metavar="<file>",
	help="specify a batch operation file (for cronjob etc)")
params.add_argument("--bindex", action="store_true",
	help="like --index but output is in batchfile format")
params.add_argument("-a", "--print-auth", action="store_true",
	help="print debug iView auth information")
params.add_argument("-c", "--cache", metavar="<dir>",
	help="use cache directory for debugging")
params.add_argument("-x", "--proxy", metavar="<host:port>",
	help="used specified SOCKS proxy")

if len(sys.argv) <= 1:
	params.print_help(sys.stderr)
	sys.exit(2)
args = params.parse_args()

try:
	if args.proxy is not None:
		err = parse_proxy_argument(args.proxy)
		if err is not None:
			print("Invalid proxy specification: %s\n" % err, file=sys.stderr)
			params.print_usage(sys.stderr)
			sys.exit(4)

	# iview.comm (and therefore iview.fetch) can only be imported after
	# configuring the proxy as we need to override the socket before
	# importing urllib
	import iview.fetch
	import iview.comm
	from iview.comm import HTTPError

	if args.cache is not None:
		iview.comm.cache = args.cache
	if args.programme:
		programme()
	if args.index:
		index()
	if args.bindex:
		batch_index()
	if args.series is not None:
		series(args.series)
	if args.print_auth:
		print_auth()

except KeyboardInterrupt: # don't traceback on a Ctrl+C
	pass

if args.download is not None:
	download(args.download, args.output)
elif args.subtitles is not None:
	subtitles(args.subtitles, args.output)
elif args.batch is not None:
	batch(args.batch)
